function [otf,dphi] = modes2Otf(Cmm,modes,pupil,npsf,varargin)
inputs = inputParser;
inputs.addRequired('Cmm',@isnumeric);
inputs.addRequired('modes',@isnumeric);
inputs.addRequired('pupil',@isnumeric);
inputs.addRequired('npsf',@isnumeric);
inputs.addParameter('D',11.25,@isnumeric);
inputs.addParameter('dk',43,@isnumeric);
inputs.addParameter('method','Vii',@ischar);
inputs.parse(Cmm,modes,pupil,npsf,varargin{:});

method       = inputs.Results.method;
D = inputs.Results.D;
dk = inputs.Results.dk;

if any(Cmm(:))
            
    switch method
        
        case 'Vii'
            % Autocorrelation of the pupil expressed in pupil
            nPx        = sqrt(size(modes,1));
            n = 2;
            pupExtended= fftshift(puakoTools.enlargePupil(double(pupil),n));
            fftPup     = fft2(pupExtended);
            conjPupFft = conj(fftPup);
            G          = fftshift(real(fft2(fftPup.*conjPupFft)));
            % Defining the inverse
            den        = zeros(size(G));
            msk        = G./max(G(:)) > 1e-7;
            den(msk)   = 1./G(msk);
            % Diagonalizing the Cvv matrix
            [U,S]   = svd(Cmm);
            s       = diag(S);
            nModes  = length(s);
            M       = modes * U;
            %loop on actuators            
            buf = zeros(size(pupExtended));            
            for k=1:nModes
                Mk   = reshape(M(:,k),nPx,nPx);
                Mk   = fftshift(puakoTools.enlargePupil(Mk,n));
                % Vii computation
                Vk   = real(fft2(Mk.^2.*pupExtended).*conjPupFft) - abs(fft2(Mk.*pupExtended)).^2;
                % Summing modes into dm basis
                buf  = buf + s(k) .* Vk;
            end            
            dphi     = den.*fftshift(real(fft2(2*buf)));
            otf      = G.*exp(-0.5*dphi);
            
        case 'Uij'
            % Autocorrelation of the pupil expressed in pupil
            nPx        = sqrt(size(modes,1));
            pupExtended= fftshift(puakoTools.enlargePupil(double(pupil),2));
            fftPup     = fft2(pupExtended);
            conjPupFft = conj(fftPup);
            G          = fftshift(real(fft2(fftPup.*conjPupFft)));
            % Defining the inverse
            den        = zeros(size(G));
            msk        = G./max(G(:)) > 1e-7;
            den(msk)   = 1./G(msk);
            nm   = size(modes,2);
            dphi = 0*pupExtended;
            
            %Double loops on modes
            for i=1:nm
                Mi = reshape(modes(:,i),nPx,nPx);
                Mi = puakoTools.enlargePupil(Mi,2);
                for j=1:i
                    %Getting modes + interpolation to twice resolution
                    Mj    = reshape(modes(:,j),nPx,nPx);
                    Mj   = puakoTools.enlargePupil(Mj,2);
                    term1 = real(fft2(Mi.*Mj.*pupExtended).*conjPupFft);
                    term2 = real(fft2(Mi.*pupExtended).*conj(fft2(Mj.*pupExtended)));
                    % Uij computation
                    Uij   = real(ifft2(term1-term2));
                    %Summing terms
                    fact = double(i~=j) + 1;
                    dphi = dphi + fact*Cmm(i,j).*Uij;
                end
            end
            dphi = fftshift(dphi).*den.*msk;
            otf  = G.*exp(-0.5*dphi);
            
        case 'zonal'            
            % Phase covariance function
            dk = sqrt(size(modes,1));
            idxvalid = logical(puakoTools.interpolate(pupil,dk));
            Cphi = modes*Cmm*modes';
            dphi = 2*(diag(Cphi) - Cphi);
            % Grabbing the valid actuators positions in meters           
            dp = D/(dk-1);
            loc  = pointWiseLocation(D,dp,idxvalid(:));
            %OTF sampling
            nPh  = round(D/dp+1);
            %nU1d = 2*nPh;
            u1D  = (-nPh:1:nPh-1)*dp;
            nU1d = length(u1D);
            % Determining couples of point with the same separation
            [shiftX,shiftY] = mkotf_indpts(nU1d,nPh,u1D,loc,dp);
            % WF Amplitude
            amp0 = ones(nnz(idxvalid(:)),1);
            
            %% Long-exposure OTF
            otf = mkotf(shiftX,shiftY,nU1d,amp0,dp,-0.5*Cphi(idxvalid(:),idxvalid(:)));
            G = mkotf(shiftX,shiftY,nU1d,amp0,dp,0*Cphi);           
            if size(otf,1) ~= npsf
                otf = puakoTools.interpolateOtf(otf,npsf);
                G= puakoTools.interpolateOtf(G,npsf);
            end
            otf = otf./max(otf(:));
            G = G/max(G(:));            
            otf(G>1e-5) = otf(G>1e-5)./G(G>1e-5);
    end
else
    % Diffraction-limit case
    nPx        = sqrt(size(modes,1));
    pupExtended= fftshift(puakoTools.enlargePupil(double(pupil),2));
    fftPup     = fft2(pupExtended);
    conjPupFft = conj(fftPup);
    G          = fftshift(real(fft2(fftPup.*conjPupFft)));
    G    = G./max(G(:));
    otf  = G;
    dphi = 0*G;
end
% Interpolation of the OTF => determination of the PSF fov
otf = otf.*(G>1e-5);
if size(otf,1) ~= npsf
    otf = puakoTools.interpolateOtf(otf,npsf);
    otf = otf./max(otf(:));
    dphi= puakoTools.interpolateOtf(dphi,npsf);
end

%Zonal calculation
function out = pointWiseLocation(D,dp,idxValid)
% Defining the point-wise locations
xloc                 = -D/2:dp:D/2;
[actuLocX, actuLocY] = meshgrid(xloc);
actuLocX             = actuLocX(idxValid);
actuLocY             = actuLocY(idxValid);
out                  = [actuLocX(:), actuLocY(:)];


function otf = mkotf(indptsc,indptsc2,nU1d,ampl,dp,C_phi)

%Instantiation
otf         = zeros(nU1d);
C_phip_diag = exp(diag(C_phi));
C_phipi     = exp(-2*C_phi);
C_phi_size2 = size(C_phi,2);

for iu=1:nU1d
    for ju=1:nU1d
        indpts  = indptsc{iu, ju};
        indpts2 = indptsc2{iu, ju};
        
        if isempty(indpts)
            otf(iu,ju) = 0;
        else
            myarg      = C_phip_diag(indpts2).*C_phip_diag(indpts)...
                .*C_phipi(C_phi_size2*(indpts-1) + indpts2);
            kernel     = (conj(ampl(indpts2)) .* ampl(indpts))' * myarg;
            otf(iu,ju) = kernel*dp^2;
        end % if isempty(mypts)
    end %ju
end %iu

dc  = sum(abs(ampl).^2) * dp^2;
otf = otf/dc;


function [indptsc,indptsc2] = mkotf_indpts(nU1d,nPh,u1D,loc,dp)

% index pts in a 3x bigger array
locInPitch = loc/dp;
minLoc     = min(locInPitch);
ninloc     = size(loc,1);
nc         = 3*nPh;
n          = nc-nPh;
n1         = (n-mod(n,2))/2 + 1 + mod(nPh,2);
minLoc2    = minLoc -(n1-1);
loc2       = round(locInPitch - ones(ninloc,1)*minLoc2+1);
%embed the loc2 inside ncxnc array.
indx_emb       = loc2(:,1)+(loc2(:,2)-1)*nc;
mask           = zeros(nc);
mask(indx_emb) = 1;
indptsc        = cell(nU1d);
indptsc2       = cell(nU1d);

for iu=1:nU1d
    for ju=1:nU1d
        u2D        = [u1D(iu)  u1D(ju)];
        uInPitch   = u2D/dp;
        iniloc_sh2 = loc2 + ones(ninloc,1)*round(uInPitch);
        indxsh     = iniloc_sh2(:,1) + (iniloc_sh2(:,2)-1)*nc;
        
        %index of points in iniloc_sh2 that are intersect with iniloc_sh
        %indpts is the overlapping points in the shifted array
        indptsc{ju,iu}  = find(mask(indxsh));
        mask2           = zeros(nc);
        mask2(indxsh)   = 1;
        indptsc2{ju,iu} = find(mask2(indx_emb));
    end
end
